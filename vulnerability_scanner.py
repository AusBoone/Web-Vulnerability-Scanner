import requests
import socket
from urllib.parse import urljoin

class VulnerabilityScanner:
    def __init__(self, site_map):
        self.site_map = site_map

    def run(self):
        """Run all vulnerability tests."""
        self.check_for_sql_injection()
        self.check_for_xss()

    def check_for_sql_injection(self):
        """Check for SQL injection vulnerabilities."""
        sql_payloads = [
            "'", "''", "\"", "\"\"", "1' OR '1'='1", "1\" OR \"1\"=\"1",
            "admin'--", "admin' #", "admin'/*", "' or 1=1--", "\" or 1=1--"
        ]

        for url in self.site_map:
            for payload in sql_payloads:
                malicious_url = url + payload
                response = requests.get(malicious_url)

                if "error" in response.text.lower():
                    print(f"[!] Potential SQL injection vulnerability found at {malicious_url}")
    
    def check_for_xss(self):
        """Check for XSS vulnerabilities."""
        xss_payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<body onload=alert('XSS')>"
        ]

        for url in self.site_map:
            forms = self.extract_forms(url)
            for form in forms:
                for payload in xss_payloads:
                    form_data = self.get_form_data(form, payload)
                    response = self.submit_form(form, form_data, url)

                    if payload in response.text:
                        print(f"[!] Potential XSS vulnerability found at {url}")

    def check_for_ssrf(self, url):
        """Check for Server-Side Request Forgery (SSRF) vulnerabilities."""
        ssrf_payload = "http://localhost"  # or any other URL to test
        # A function that sends a GET request with the payload as a query parameter
        response = requests.get(url, params={"url_param": ssrf_payload})
        if "ssrf_vulnerable_indicator" in response.text:
            print(f"SSRF vulnerability found at {url}")

    """
    I will assume there is an API endpoint that returns user information based on user IDs. 
    The IDOR vulnerability occurs when an attacker is able to access information of other users by manipulating the user ID parameter.
    Here's a simple working function to test for IDOR vulnerabilities.

    This example assumes a valid authentication token and a known user ID for the target application. 
    This will need to adjusted to fit the specific application being tested.
    """
    def check_for_idor(self, url, known_user_id):
        """Check for Insecure Direct Object Reference (IDOR) vulnerabilities."""
        # Replace this with the target application's authentication token
        auth_token = "your_auth_token"

        # Send a request to the API with the known user ID
        response = requests.get(f"{url}/api/users/{known_user_id}", headers={"Authorization": f"Bearer {auth_token}"})
        if response.status_code == 200:
            # Increment the user ID to test for unauthorized access
            manipulated_id = known_user_id + 1
            new_url = f"{url}/api/users/{manipulated_id}"
            response = requests.get(new_url, headers={"Authorization": f"Bearer {auth_token}"})
            if response.status_code == 200:
                print(f"IDOR vulnerability found at {new_url}")

    def check_open_ports(self, url):
        # List of common ports to check for open status
        common_ports = [21, 22, 23, 80, 443, 445, 1433, 3306, 3389, 8080]

        # Iterate through the list of common ports
        for port in common_ports:
            try:
                # Attempt to create a connection to the target URL on the current port
                with socket.create_connection((url, port), timeout=1):
                    # If the connection is successful, the port is open
                    print(f"Open port found: {port}")
            except (socket.timeout, ConnectionRefusedError):
                # If the connection times out or is refused, the port is considered closed
                pass

    def check_insecure_headers(self, url):
        # Send an HTTP GET request to the target URL
        response = requests.get(url)
        # Extract the headers from the response
        headers = response.headers
        # Initialize an empty list to store insecure headers
        insecure_headers = []

        # Check for missing or insecurely configured security headers
        if "X-Content-Type-Options" not in headers:
            insecure_headers.append("X-Content-Type-Options header missing")
        if "X-Frame-Options" not in headers:
            insecure_headers.append("X-Frame-Options header missing")
        if "X-XSS-Protection" not in headers:
            insecure_headers.append("X-XSS-Protection header missing")

        # If any insecure headers were found, report them
        if insecure_headers:
            print(f"Insecure headers found at {url}:")
            for header in insecure_headers:
                print(f"  - {header}")

    @staticmethod
    def extract_forms(url):
        """Extract all forms from a given URL using the Crawler class."""
        from crawler import Crawler
        crawler = Crawler(url)
        return crawler.extract_forms(url)

    @staticmethod
    def get_form_data(form, value):
        """Prepare form data with the provided value for each input field."""
        form_data = {}
        for input_field in form.find_all("input"):
            input_name = input_field.get("name")
            input_type = input_field.get("type")
            input_value = input_field.get("value")

            if input_type == "text" or input_type == "search":
                form_data[input_name] = value
            else:
                form_data[input_name] = input_value
        return form_data

    @staticmethod
    def submit_form(form, form_data, url):
        """Submit a form with the given form data."""
        action = form.get("action")
        method = form.get("method").lower()
        form_url = urljoin(url, action)

        if method == "post":
            response = requests.post(form_url, data=form_data)
        else:
            response = requests.get(form_url, params=form_data)
        return response
